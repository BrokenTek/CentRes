DROP TRIGGER IF EXISTS beforeInsertTableLog;
DROP TRIGGER IF EXISTS afterInsertTableLog;
DROP TRIGGER IF EXISTS afterDeleteTicketItem;

DROP PROCEDURE IF EXISTS createUser;
DROP PROCEDURE IF EXISTS login;
DROP PROCEDURE IF EXISTS logout;
DROP FUNCTION IF EXISTS loggedIn;
DROP FUNCTION IF EXISTS sessionUsername;
DROP FUNCTION IF EXISTS sessionRole;
DROP FUNCTION IF EXISTS userPasswordHash;
DROP FUNCTION IF EXISTS usernameFromId;
DROP FUNCTION IF EXISTS idFromUsername;

DROP PROCEDURE IF EXISTS createTicket;
DROP PROCEDURE IF EXISTS createTicketItem;
DROP PROCEDURE IF EXISTS assignEmployeeToTable; -- TODO
DROP PROCEDURE IF EXISTS removeEmployeeFromTable; -- TODO
DROP PROCEDURE IF EXISTS assignTicketToTable; -- TODO
DROP PROCEDURE IF EXISTS removeTicketFromTable; -- TODO
DROP PROCEDURE IF EXISTS enableTable; -- TODO
DROP PROCEDURE IF EXISTS disableTable; -- TODO
DROP PROCEDURE IF EXISTS bussingComplete; -- TODO

DROP FUNCTION IF EXISTS menuItemPrice; -- TODO
DROP FUNCTION IF EXISTS ticketItemPrice; -- TODO
DROP FUNCTION IF EXISTS splitSubtotal; -- TODO
DROP FUNCTION IF EXISTS menuItemModifications;
DROP FUNCTION IF EXISTS mipHelperFunction;
DROP FUNCTION IF EXISTS ticketItemStatus;
DROP FUNCTION IF EXISTS ticketSplitFlag;

DROP TRIGGER IF EXISTS beforeAddMenuCategory;
DROP TRIGGER IF EXISTS beforeAddMenuItem;
DROP TRIGGER IF EXISTS beforeAddMenuModificationCategory;
DROP TRIGGER IF EXISTS beforeAddMenuModificationItem;
DROP TRIGGER IF EXISTS beforeUpdateMenuCategory;
DROP TRIGGER IF EXISTS beforeUpdateMenuItem;
DROP TRIGGER IF EXISTS beforeUpdateMenuModificationCategory;
DROP TRIGGER IF EXISTS beforeUpdateMenuModificationItem;
DROP TRIGGER IF EXISTS afterDeleteMenuCategory;
DROP TRIGGER IF EXISTS afterDeleteMenuItem;
DROP TRIGGER IF EXISTS afterDeleteMenuModificationCategory;
DROP TRIGGER IF EXISTS afterDeleteMenuModificationItem;

DROP PROCEDURE IF EXISTS createTicket;
DROP PROCEDURE IF EXISTS createTicketItem;
DROP PROCEDURE IF EXISTS modifyTicketItem;
DROP PROCEDURE IF EXISTS removeTicketItem;
DROP PROCEDURE IF EXISTS overrideTicketItemPrice;



DELIMITER $$
CREATE TRIGGER beforeAddMenuCategory
BEFORE INSERT ON MenuCategories FOR EACH ROW
BEGIN
	INSERT INTO QuickCodes (id) VALUES (NEW.quickCode);
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER beforeAddMenuItem
BEFORE INSERT ON MenuItems FOR EACH ROW
BEGIN
	INSERT INTO QuickCodes (id) VALUES (NEW.quickCode);
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER beforeAddMenuModificationCategory
BEFORE INSERT ON MenuModificationCategories FOR EACH ROW
BEGIN
	INSERT INTO QuickCodes (id) VALUES (NEW.quickCode);
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER beforeAddMenuModificationItem
BEFORE INSERT ON MenuModificationItems FOR EACH ROW
BEGIN
	INSERT INTO QuickCodes (id) VALUES (NEW.quickCode);
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER afterDeleteMenuCategory
AFTER DELETE ON MenuCategories FOR EACH ROW
BEGIN
	DELETE FROM QuickCodes WHERE id = OLD.quickCode;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER afterDeleteMenuItem
AFTER DELETE ON MenuItems FOR EACH ROW
BEGIN
	DELETE FROM QuickCodes WHERE id = OLD.quickCode;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER afterDeleteMenuModificationCategory
AFTER DELETE ON MenuModificationCategories FOR EACH ROW
BEGIN
	DELETE FROM QuickCodes WHERE id = OLD.quickCode;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER afterDeleteMenuModificationItem
AFTER DELETE ON MenuModificationItems FOR EACH ROW
BEGIN
	DELETE FROM QuickCodes WHERE id = OLD.quickCode;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER beforeUpdateMenuCategory
BEFORE UPDATE ON MenuCategories FOR EACH ROW
BEGIN
	IF (OLD.quickCode <> NEW.quickCode) THEN
		IF ((SELECT COUNT(*) FROM menuCategories WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuItems WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuModificationCategories WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuModificationItems WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		END IF; 
	END IF;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER beforeUpdateMenuItem
BEFORE UPDATE ON MenuItems FOR EACH ROW
BEGIN
	IF (OLD.quickCode <> NEW.quickCode) THEN
		IF ((SELECT COUNT(*) FROM menuCategories WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuItems WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuModificationCategories WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuModificationItems WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		END IF; 
	END IF;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER beforeUpdateMenuModificationCategory
BEFORE UPDATE ON MenuModificationCategories FOR EACH ROW
BEGIN
	IF (OLD.quickCode <> NEW.quickCode) THEN
		IF ((SELECT COUNT(*) FROM menuCategories WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuItems WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuModificationCategories WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuModificationItems WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		END IF; 
	END IF;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER beforeUpdateMenuModificationItem
BEFORE UPDATE ON MenuModificationItems FOR EACH ROW
BEGIN
	IF (OLD.quickCode <> NEW.quickCode) THEN
		IF ((SELECT COUNT(*) FROM menuCategories WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuItems WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuModificationCategories WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuModificationItems WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		END IF; 
	END IF;
END$$
DELIMITER ;






DELIMITER $$
CREATE TRIGGER beforeInsertTableLog
BEFORE INSERT ON TableLog FOR EACH ROW
BEGIN
	
	IF ((SELECT COUNT(*) FROM EmployeeLog WHERE employeeId = NEW.authorizationId AND startTime IS NOT NULL AND endTime IS NULL) = 0) THEN
		-- authorizer isn't logged in
	    -- This is going to bog down the system the longer the EmployeeLog gets. Need to set up trigger to add/remove logged in employees from another table.
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Authorized host must be logged in!';
		
		
		-- authorizer has invalid roles for session to perform action
	ELSEIF ((NEW.ticketId IS NOT NULL) AND (SELECT COUNT(*) FROM Tickets WHERE id = NEW.ticketId) = 0) THEN
		-- if a ticket number is specified, but it's invalid
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Specifed ticket number does not exist!';
	
		-- If you are assigning a server to table, but they aren't logged in or don't have server roles for session
	ELSEIF (NEW.tableId IS NOT NULL AND (SELECT COUNT(*) FROM Tables WHERE id = NEW.tableId AND status IN ('Occupied', 'Unavailable')) = 1) THEN
		-- if you're assigning a ticket to a table, but it's occupied or unavailable	
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Cannot assign a Ticket to an Unassigned or Occupied Table!';
	ELSEIF (NEW.action = 'Bused' AND (SELECT COUNT(*) FROM Tables WHERE id = NEW.tableId AND status = 'Bussing') = 0) THEN	
		-- if you're setting the bused flag but the table isn't flagged as bussing
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Specified Table is not marked for bussing. Cannot set status to bused.';
	-- ELSEIF () THEN
		-- if you're removing the only server, but the table is occupied and you're not removing the ticket
	
		-- if you're trying to set the table as disabled but the table is occupied
	END IF;
	
	
END$$
DELIMITER ;

-- add employee to table
DELIMITER $$
CREATE PROCEDURE assignEmployeeToTable(IN employeeId INT UNSIGNED, IN tableId VARCHAR(3), authorizationId INT UNSIGNED)
BEGIN
	DECLARE empId INT UNSIGNED;
	DECLARE hashReturn CHAR(60);
	
END$$
DELIMITER ;

-- add remove employee from table
DELIMITER $$
CREATE PROCEDURE removeEmployeeFromTable(IN employeeId INT UNSIGNED, IN tableId VARCHAR(3), authorizationId INT UNSIGNED)
BEGIN
		
END$$
DELIMITER ;

-- add ticket to table
DELIMITER $$
CREATE PROCEDURE assignTicketToTable(IN ticketId VARCHAR(3), IN tableId VARCHAR(3), authorizationId INT UNSIGNED)
BEGIN
		
END$$
DELIMITER ;

-- remove ticket from table
DELIMITER $$
CREATE PROCEDURE removeTicketFromTable(IN ticketId VARCHAR(3), IN tableId VARCHAR(3), authorizationId INT UNSIGNED)
BEGIN
		
END$$
DELIMITER ;

-- disable table
DELIMITER $$
CREATE PROCEDURE disableTable(IN tableId VARCHAR(3))
BEGIN
		
END$$
DELIMITER ;

-- enable table
DELIMITER $$
CREATE PROCEDURE enableTable(IN tableId VARCHAR(3))
BEGIN
		
END$$
DELIMITER ;

-- set table status to bussed
DELIMITER $$
CREATE PROCEDURE bussingComplete(IN tableId VARCHAR(3))
BEGIN
		
END$$
DELIMITER ;


DELIMITER $$
CREATE TRIGGER afterInsertTableLog
AFTER INSERT ON TableLog FOR EACH ROW
BEGIN
	DECLARE timeStmp DATETIME;
	IF (NEW.action = 'Add' AND NEW.ticketId IS NOT NULL AND NEW.employeeId IS NOT NULL) THEN
		UPDATE Tickets SET tableId = NEW.tableId, timeSeated = NOW() WHERE id = NEW.ticketId;
		INSERT INTO TableAssignments VALUES(NEW.employeeId, NEW.tableId);
		UPDATE Tables SET status = 'Seated' WHERE id = NEW.tableId;
	ELSEIF (NEW.action = 'Add' AND NEW.ticketId IS NOT NULL) THEN
		UPDATE Tickets SET tableId = NEW.tableId, timeSeated = NOW() WHERE id = NEW.ticketId;
		UPDATE Tables SET status = 'Seated' WHERE id = NEW.tableId;
	ELSEIF (NEW.action = 'Add' AND NEW.employeeId IS NOT NULL) THEN
		INSERT INTO TableAssignments VALUES(NEW.employeeId, NEW.tableId);
		IF (SELECT COUNT(*) FROM Tickets WHERE tableId = NEW.TableId > 0) THEN
			UPDATE Tables SET status = 'Seated' WHERE id = NEW.tableId;
		ELSE
			UPDATE Tables SET status = 'Open' WHERE id = NEW.tableId;
		END IF;
	ELSEIF (NEW.action = 'Remove' AND NEW.ticketId IS NOT NULL AND NEW.employeeId IS NOT NULL) THEN
		DELETE FROM TableAssignments WHERE employeeId = NEW.employeeId AND tableId = NEW.tableId;
		UPDATE Tickets SET tableId = NULL WHERE id = NEW.ticketId;
		UPDATE Tables SET status = 'Bussing' WHERE id = NEW.tableId;
	ELSEIF (NEW.action = 'Remove' AND NEW.ticketId IS NOT NULL) THEN
		UPDATE Tickets SET tableId = NULL WHERE id = NEW.ticketId;
		UPDATE Tables SET status = 'Bussing' WHERE id = NEW.tableId;
	ELSEIF (NEW.action = 'Remove' AND NEW.employeeId IS NOT NULL) THEN
		DELETE FROM TableAssignments WHERE employeeId = NEW.employeeId and tableId = NEW.tableId;
		IF (((SELECT COUNT(*) FROM Tickets WHERE tableId = NEW.TableId) = 0) AND 
		((SELECT COUNT(*) FROM Tables WHERE id = NEW.tableId and status = 'Bussing')) = 0) THEN
			UPDATE Tables SET status = 'Unassigned' WHERE id = NEW.tableId;
		END IF;
	ELSEIF (NEW.action = 'Bused') THEN
		IF ((SELECT COUNT(*) FROM TableAssignments WHERE tableId = NEW.TableId) = 0) THEN
			UPDATE Tables SET status = 'Unassigned' WHERE id = NEW.tableId;
		ELSE
			UPDATE Tables SET status = 'Open' WHERE id = NEW.tableId;
		END IF;
	ELSEIF (NEW.action = 'Disable') THEN
		UPDATE Tables SET status = 'Unavailable' WHERE id = NEW.tableId;
	ELSEIF (NEW.action = 'Enable') THEN
		IF ((SELECT COUNT(*) FROM TableAssignments WHERE tableId = NEW.TableId) = 0) THEN
			UPDATE Tables SET status = 'Unassigned' WHERE id = NEW.tableId;
		ELSE
			UPDATE Tables SET status = 'Open' WHERE id = NEW.tableId;
		END IF;
	END IF;
END$$
DELIMITER ;

DELIMITER $$
CREATE FUNCTION userPasswordHash(uname VARCHAR(25)) RETURNS CHAR(60)
BEGIN
	DECLARE empId INT UNSIGNED;
	DECLARE hashReturn CHAR(60);
	IF ((SELECT COUNT(*) FROM Employees WHERE userName = uname) = 0) THEN
		-- Invalid Employee Id
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Username not found!';
	ELSE
		SELECT passwordBCrypt INTO hashReturn FROM Employees WHERE userName = uname;
		RETURN hashReturn;
	END IF;
	
END$$
DELIMITER ;

DELIMITER $$

CREATE FUNCTION usernameFromId(empId INT UNSIGNED) RETURNS VARCHAR(25)
BEGIN
	DECLARE uname VARCHAR(25);
	IF ((SELECT COUNT(*) FROM Employees WHERE id = empId) = 0) THEN
		-- Invalid Employee Id
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Invalid Employee Id!';
	ELSE
		SELECT userName INTO uname FROM Employees WHERE id = empId;
		RETURN uname;
	END IF;
	
END$$
DELIMITER ;

DELIMITER $$
CREATE FUNCTION idFromUsername(uname VARCHAR(25)) RETURNS INT UNSIGNED
BEGIN
	DECLARE empId INT UNSIGNED;
	IF ((SELECT COUNT(*) FROM Employees WHERE userName = uname) = 0) THEN
		-- Invalid Username
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Username not found!';
	ELSE
		SELECT id INTO empId FROM Employees WHERE userName = uname;
		RETURN empId;
	END IF;
END$$
DELIMITER ;

-- parent Quick code is required because Menu Items can belong to more than 1 Menu Item Category.
-- specifying the parent uniquely identifies a specific instance of the menu item.
DELIMITER $$
CREATE FUNCTION menuItemPrice(qc VARCHAR(10), parentQuickCode VARCHAR(10)) RETURNS DECIMAL(6, 2)
BEGIN
	DECLARE prc DECIMAL(6, 2);
	SELECT price INTO prc FROM MenuItems WHERE id = qc; 
	RETURN mipHelperFunction(parentQuickCode, prc, NULL, NULL, NULL);
END$$
DELIMITER ;

DELIMITER $$
CREATE FUNCTION mipHelperFunction(qc VARCHAR(10), basePrice DECIMAL(6, 2), minPercentage DECIMAL(6, 2), minDiscount DECIMAL(6, 2), minPriceOverride DECIMAL(6,2)) RETURNS DECIMAL(6, 2)
BEGIN
	DECLARE selectedValue DECIMAL(6, 2);
	DECLARE defPrice DECIMAL(6, 2);
	DECLARE done INT DEFAULT FALSE;
	DECLARE parentQC VARCHAR(10);
	DECLARE myCursor CURSOR
		FOR 
			SELECT priceModificationValue FROM MenuModificationItems INNER JOIN MenuAssociations ON MenuModificationItems.quickCode = MenuAssociations.childQuickCode WHERE parentQuickCode = qc;
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
	
	OPEN myCursor;
	modItemsLoop:
	LOOP
		FETCH myCursor INTO selectedValue;
		IF (done = 1) THEN
			LEAVE modItemsLoop;
		END IF;
		IF (selectedValue = 0) THEN
			CLOSE myCursor;
			RETURN 0;
		ELSEIF (selectedValue < 0 AND (selectedValue < minDiscount OR minDiscount IS NULL)) THEN
			SET minDiscount = selectedValue;
		ELSEIF (selectedValue > 0 AND selectedValue < 1 and (selectedValue < minDiscount OR minDiscount IS NULL)) THEN
			SET minPercentage = selectedValue;
		ELSEIF (selectedValue >= 1 AND (selectedValue < minPriceOverride OR minPriceOverride IS NULL)) THEN
			SET minPriceOverride = selectedValue;
		END IF;
	END LOOP modItemsLoop;
	CLOSE myCursor;

	IF (basePrice IS NULL) Then
		SELECT defaultPrice INTO basePrice FROM MenuCategories WHERE quickCode = qc;
	End If;

	SELECT parentQuickCode INTO parentQC FROM TableAssociations WHERE childQuickCode = qc;
	IF (basePrice - minDiscount < 0) THEN
		SET minDiscount = 0;
	END IF;
	IF parentQC IS NULL THEN
		IF (basePrice IS NULL and minPriceOverride IS NULL) Then
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Menu Item doesn''t have a price set, and cannot be inferred from ancestors!';
		ELSE
			SET selectedValue = basePrice;
			IF (minPercentage IS NOT NULL AND basePrice * minPercentage < selectedValue) THEN
				SET selectedValue = basePrice * minPercentage;
			End IF;
			IF (minDiscount IS NOT NULL AND basePrice + minDiscount < selectedValue) THEN
				SET selectedValue = basePrice + minDiscount;
			End IF;
			IF (minPriceOverride IS NOT NULL AND minPriceOverride < selectedValue) THEN
				SET selectedValue = basePrice + minDiscount;
			End IF;
			RETURN selectedValue;
		END IF;
	ELSE
		RETURN mipHelperFunction(parentQC, basePrice, minPercentage, minDiscount, minPriceOverride);
	END IF;
	
END$$
DELIMITER ;

DELIMITER $$
CREATE FUNCTION menuItemModifications(qc VARCHAR(10), parentQC VARCHAR(10)) RETURNS VARCHAR(500)
BEGIN
	DECLARE inString VARCHAR(10);
	DECLARE myString VARCHAR(500);

	DECLARE done INT DEFAULT FALSE;
	DECLARE myCursor CURSOR
		FOR 
			SELECT childQuickCode FROM MenuAssociations INNER JOIN MenuModificationCategories ON MenuAssociations.childQuickCode = MenuModificationsCategories.quickCode WHERE parentQuickCode = parentQC;
	DECLARE myCursor2 CURSOR
		FOR 
			SELECT childQuickCode FROM MenuAssociations INNER JOIN MenuModificationCategories ON MenuAssociations.childQuickCode = MenuModificationsCategories.quickCode WHERE parentQuickCode = qc;
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
	
	OPEN myCursor;
	modItemsLoop:
	LOOP
		FETCH myCursor INTO inString;
		IF (done = 1) THEN
			LEAVE modItemsLoop;
		END IF;
		UPDATE myString SET myString = myString + ',' + inString;
		
	END LOOP modItemsLoop;
	CLOSE myCursor;
	SET done = FALSE;
	
	OPEN myCursor2;
	modItemsLoop2:
	LOOP
		FETCH myCursor INTO inString;
		IF (done = 1) THEN
			LEAVE modItemsLoop2;
		END IF;
		UPDATE myString SET myString = myString + ',' + inString;
		
	END LOOP modItemsLoop2;
	CLOSE myCursor2;

	RETURN myString + ',';

END$$
DELIMITER ;



-- function needs to be recoded to include appropriate price calculation
DELIMITER $$
CREATE FUNCTION ticketItemPrice(ticketItemId INT UNSIGNED) RETURNS DECIMAL(6, 2)
BEGIN
	DECLARE miQuickCode VARCHAR(10);
	DECLARE price DECIMAL(6, 2);
	SELECT menuItemQuickCode INTO miQuickCode FROM TicketItems WHERE id = ticketItemId;
	SELECT basePrice INTO price FROM MenuItems WHERE quickCode = miQuickCode;
	RETURN price;	
END$$
DELIMITER ;

DELIMITER $$
CREATE FUNCTION sessionRole(token VARCHAR(60)) RETURNS INT UNSIGNED
BEGIN
	DECLARE empId INT UNSIGNED;
	DECLARE role INT UNSIGNED;
	SELECT id INTO empId FROM Employees WHERE accessToken = token AND accessTokenExpiration > NOW();
	IF (empId IS NULL) THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Access Token Expired Or Doesn''t Exist!';
	ELSE
		SELECT employeeRole INTO role FROM ActiveEmployees WHERE employeeId = empId;
		RETURN role;
	END IF;
END$$
DELIMITER ;


DELIMITER $$
CREATE FUNCTION sessionUsername(token VARCHAR(60)) RETURNS VARCHAR(25)
BEGIN
	 DECLARE uname VARCHAR(25);
	 SELECT userName INTO uname FROM Employees WHERE accessToken = token AND accessTokenExpiration > NOW();
	IF (uname IS NULL) THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Access Token Expired Or Doesn''t Exist!';
	ELSE
		RETURN uname;
	END IF;
END$$
DELIMITER ;


DELIMITER $$
CREATE FUNCTION loggedIn(uname VARCHAR(25)) RETURNS BOOLEAN
BEGIN
	DECLARE endTime DATETIME;
	DECLARE empId INT UNSIGNED;
	SELECT id INTO empId FROM Employees WHERE userName = uname;
	SELECT accessTokenExpiration INTO endTime FROM Employees WHERE userName = uname;
	IF (empId IS NULL) THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Username Not Found!';
	ELSEIF (endTime IS NULL OR endTime < NOW()) THEN
		RETURN FALSE;
	ELSE
		RETURN TRUE;
	END IF;
END$$
DELIMITER ;


DELIMITER $$
CREATE PROCEDURE createUser(IN lName VARCHAR(50), fName VARCHAR(60), IN uName VARCHAR(25), IN pHash VARCHAR(60), IN roles TINYINT UNSIGNED)
BEGIN
	INSERT INTO Employees (lastName, firstName, userName, passwordBCrypt, roleLevel) VALUES (lName, fName, uname, pHash, roles);
END$$
DELIMITER ;


DELIMITER $$
CREATE PROCEDURE login(IN requestedUsername VARCHAR(25), IN requestedRoles TINYINT UNSIGNED, IN newAccessToken varchar(60))
BEGIN
	DECLARE allowedRoles TINYINT UNSIGNED;
	DECLARE empId INT UNSIGNED;
	DECLARE timeoutMins INT UNSIGNED;
	IF ((SELECT COUNT(*) FROM Employees WHERE userName = requestedUsername) = 0) THEN
		-- Invalid Employee Id
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Username not found!';
	ELSE
		SELECT roleLevel INTO allowedRoles FROM Employees WHERE userName = requestedUsername;
		
		IF (allowedRoles & requestedRoles <> requestedRoles) THEN
			-- Invalid Requested Roles
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'You do not have the authorization to login with the role you sepcified!';
		ELSEIF ((SELECT COUNT(*) FROM Employees WHERE userName = requestedUsername AND accessToken IS NOT NULL AND accessTokenExpiration > now()) = 1) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'You are already logged in elsewhere!';
		ELSEIF ((SELECT COUNT(*) FROM Employees WHERE accessToken = newAccessToken AND userName <> requestedUsername) = 1 ) THEN
			-- Another user is already logged in using your access key.
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Access Token Not Unique! Retry Login.';
		ELSE
					
			SELECT id INTO empId FROM Employees WHERE userName = requestedUsername;
			UPDATE EmployeeLog SET endTime = NOW() WHERE employeeId = empId and endTime IS NULL;
			INSERT INTO EmployeeLog (employeeId, employeeRole) VALUES(empId, requestedRoles);
			DELETE FROM ActiveEmployees WHERE employeeId = empId;
			INSERT INTO ActiveEmployees (employeeId, employeeRole) VALUES (empId, requestedRoles);
			SELECT (sessionTimeoutInMins * 100) INTO timeoutMins FROM Config;	
			UPDATE employees SET accessToken = newAccessToken, accessTokenExpiration = ADDTIME(NOW(), timeoutMins) WHERE userName = requestedUsername;
		END IF;
	END IF;
	
END$$
DELIMITER ;

DELIMITER $$
CREATE PROCEDURE logout(IN uname VARCHAR(25))
BEGIN
	DECLARE empId INT UNSIGNED;
	IF ((SELECT COUNT(*) FROM Employees WHERE userName = uname) = 0) THEN
		-- Invalid Employee Id
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Username not found!';
	ELSE
		SELECT id INTO empId FROM Employees WHERE userName = uname;
		UPDATE EmployeeLog SET endTime = NOW() WHERE employeeId = empId and endTime IS NULL;
		UPDATE Employees SET accessToken = NULL, accessTokenExpiration = NULL WHERE userName = uname;
		DELETE FROM ActiveEmployees WHERE employeeId = empId;
	END IF;
	
END$$
DELIMITER ;


DELIMITER $$
CREATE FUNCTION ticketItemStatus(ticketNum INT UNSIGNED) RETURNS VARCHAR(20)
BEGIN
	DECLARE flg VARCHAR(20);
	DECLARE sub DATETIME;
	DECLARE red DATETIME;
	DECLARE del DATETIME;
	DECLARE menItm VARCHAR(10);
	DECLARE rte CHAR(1);
	IF ((SELECT COUNT(*) FROM TicketItems WHERE id = ticketNum) = 0) THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Ticket Item Number Not Found!';
	ELSE
		SELECT itemId, flag, submitTime, readyTime, deliveredTime INTO menItm, flg, sub, red, del FROM TicketItems WHERE id = ticketNum;
		SELECT route into rte FROM MenuItems WHERE quickCode = menItm;
		IF (rte IS NULL) THEN
			RETURN 'n/a';
		ELSEIF (del IS NOT NULL) THEN
			RETURN 'Delivered';
		ELSEIF (red IS NOT NULL) THEN
			RETURN 'Ready';
		ELSEIF (sub IS NULL) THEN 
			RETURN 'Pending';
		ELSEIF (flg IS NULL) THEN
			RETURN 'Preparing';
		ELSE
			RETURN flg;
		END IF;
	END IF;
END$$
DELIMITER ;

DELIMITER $$
CREATE PROCEDURE createTicket(IN ticketNickname VARCHAR(25), IN peopleCount INT UNSIGNED, OUT newTicketNumber INT UNSIGNED)
BEGIN
	INSERT INTO Tickets (nickname, partySize) VALUES (ticketNickname, peopleCount);
	SELECT MAX(id) INTO newTicketNumber FROM Tickets; 
END$$
DELIMITER ;

-- todo switch to using menuItemPrice
DELIMITER $$
CREATE PROCEDURE createTicketItem(IN ticketNumber INT UNSIGNED, IN seatNumber TINYINT UNSIGNED, IN split TINYINT UNSIGNED, IN menuItemQC VARCHAR(10))
BEGIN
	DECLARE tbl VARCHAR(3);
	DECLARE newItemIndex TINYINT UNSIGNED;
	DECLARE calcPrice DECIMAL(6, 2);
	DECLARE qty SMALLINT;
	DECLARE req SMALLINT;
	DECLARE nextAvailableItmNum SMALLINT;
	SET newItemIndex = 1;
	SELECT tableId INTO tbl FROM Tickets WHERE id = ticketNumber;
	IF ((SELECT COUNT(*) FROM Tickets WHERE id = ticketNumber) = 0) THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Ticket Item Number Doesn''t Exist!';
	ELSEIF (split > 9) THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Split Number Must Not Exceed 9!';
	ELSEIF (tbl IS NULL) THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Ticket Isn''t Assigned to a Table!';
	ELSEIF ((SELECT count(quickCode) FROM MenuItems WHERE quickCode = menuItemQC) = 0 ) THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Menu Item Not Found!';
	ELSE
		-- todo switch to using menuItemPrice
		SELECT price, quantity, requests INTO calcPrice, qty, req FROM MenuItems WHERE quickCode = menuItemQC;
		IF (calcPrice IS NULL) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Menu Item Price Cannot Be Determined!';
		ELSE
			-- record a menu item was requested.
			UPDATE MenuItems SET requests = req + 1 WHERE quickCode = menuItemQC;
			-- negative qty is unchecked.... Thinks like drinks and stuff not routed to the
			-- kitchen should not keep track of quantity.
			IF (IFNULL(qty, 1) = 0) THEN
				SIGNAL SQLSTATE '45000'
				SET MESSAGE_TEXT = 'Menu Item Is Out of Stock!';
			ELSE
				-- new split. Add Split record.
				IF ((SELECT COUNT(*) FROM Splits WHERE ticketId = ticketNumber AND splitId = split) = 0) THEN
					INSERT INTO Splits (ticketId, splitId) VALUES (ticketNumber, split);
				END IF;

				-- find the next available item number in ticket.
				SELECT (IFNULL(MAX(itemId),0) +1) INTO newItemIndex FROM TicketItems WHERE ticketId = ticketNumber;

				-- create the ticket item
				INSERT INTO TicketItems (id, splitFlag, seat, menuItemQuickCode, calculatedPriceWithMods) VALUES (ticketNumber * 10000 + newItemIndex, POWER(2, split),  seatNumber, menuItemQC, calcPrice);
				-- SET newTicketItemID = ticketNumber * 10000 + newItemIndex;


				-- decrease the inventory by 1
				IF (qty IS NOT NULL) THEN
					UPDATE MenuItems SET quantity = qty - 1 WHERE quickCode = menuItemQC;
				END IF; 
			END IF;
			
		END IF; 
	END IF;
END$$
DELIMITER ;

DELIMITER $$
CREATE PROCEDURE modifyTicketItem(IN ticketItemNumber INT UNSIGNED, IN modNotes VARCHAR(500))
BEGIN
	DECLARE stat VARCHAR(20);
	IF ((SELECT COUNT(*) FROM TicketItems WHERE id = ticketItemNumber) = 0) THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Ticket Item Number Doesn''t Exist!';
	ELSE
		SELECT ticketItemStatus(ticketNumber) INTO stat;
		IF (stat in ('Delivered', 'Ready', 'Removed')) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Removed/Ready/Delivered Ticket Items Cannot Be Modified!';
		ELSE
			UPDATE TicketItems SET modificationNotes = modNotes WHERE id = ticketItemNumber;
			IF (stat = 'Preparing') THEN
				UPDATE TicketItems SET flag = 'Updated' WHERE id = ticketItemNumber;
			END IF; 
		END IF;
	END IF;
END$$
DELIMITER ;

DELIMITER $$
CREATE PROCEDURE overrideTicketItemPrice(IN ticketItemNumber INT UNSIGNED, IN adjustemnt DECIMAL(6, 2), note VARCHAR(500), authorizationUsername VARCHAR(25))
BEGIN
	DECLARE empId INT UNSIGNED;
	IF ((SELECT COUNT(*) FROM TicketItems WHERE id = ticketItemNumber) = 0) THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Ticket Item Number Doesn''t Exist!';
	ELSEIF (authorizationUsername IS NULL) THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Price Overrides Require Employee# to Log Event!';
	ELSE
		SELECT idFromUsername(authorizationUsername) INTO empId; 
		UPDATE TicketItems SET overridePrice = adjustment, 
		                       overrideNote = note,
							   overrideAuthorization = empId,
							   overrideTimeStamp = NOW()
						   WHERE id = ticketItemNumber;
	END IF;
END$$
DELIMITER ;

DELIMITER $$
CREATE PROCEDURE removeTicketItem(IN ticketItemNumber INT UNSIGNED)
BEGIN
	DECLARE stat VARCHAR(20);
	DECLARE spltFlg SMALLINT UNSIGNED;
	DECLARE qc VARCHAR(40);
	DECLARE qty SMALLINT UNSIGNED;
	SELECT ticketItemStatus(ticketItemNumber) INTO stat;
	SELECT menuItemQuickCode INTO qc FROM TicketItems WHERE id = ticketItemNumber;
	SELECT quantity INTO qty FROM MenuItems WHERE quickCode = qc;
	IF (stat IN ('Ready', 'Delivered', 'Hidden')) THEN
		-- Hidden is a subcategory of Delivered. The manager hides the item from the ticket and price ignored.
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Ready/Delivered Ticket Items Cannot Be Removed!';
	ELSEIF (stat IN ('Updated', 'Preparing', 'Removed')) THEN
		UPDATE TicketItems SET flag = 'Removed' WHERE id = ticketItemNumber;
	ELSE
		SELECT splitFlag into spltFlg FROM TicketItems WHERE ticketId = ticketItemNumber;
		
		-- deletes split from ticket if this is the only item on it.
		-- DELETE FROM Splits WHERE spltFlg & POWER(2, splitId) = POWER(2, splitId) AND 
		 -- POWER(2, splitId) IN (SELECT splitFlag FROM TicketItems WHERE ticketId = (ticketItemNumber DIV 10000) GROUP BY splitFlag HAVING count(*) = 1);
		
		-- delete the actual ticket item
		DELETE FROM TicketItems WHERE id = ticketItemNumber;
		
		-- increment quantity by 1 in inventory
		IF (qty IS NOT NULL) THEN
			UPDATE MenuItems SET quantity = qty + 1 WHERE quickCode = qc;
		END IF;
	END IF;
END$$
DELIMITER ;

-- moveTicketItemToSeat(ticket, seat)

-- removeTicketItemFromSplit(ticket, split)

-- addTicketItemToSplit(ticket, split)

-- moveTicketItemToSplit(ticket, split)
