DROP TRIGGER IF EXISTS beforeInsertTableLog;
DROP TRIGGER IF EXISTS afterInsertTableLog;
DROP TRIGGER IF EXISTS afterDeleteTicketModificationSplit;
DROP PROCEDURE IF EXISTS login;
DROP PROCEDURE IF EXISTS logout;
DROP PROCEDURE IF EXISTS assignEmployeeToTable;
DROP PROCEDURE IF EXISTS removeEmployeeFromTable;
DROP PROCEDURE IF EXISTS assignTicketToTable;
DROP PROCEDURE IF EXISTS removeTicketFromTable;
DROP PROCEDURE IF EXISTS enableTable;
DROP PROCEDURE IF EXISTS disableTable;
DROP PROCEDURE IF EXISTS bussingComplete;
DROP FUNCTION IF EXISTS userPasswordHash;
DROP FUNCTION IF EXISTS usernameFromID;
DROP FUNCTION IF EXISTS idFromUsername;
DROP FUNCTION IF EXISTS menuItemPrice;
DROP FUNCTION IF EXISTS mipHelperFunction;
DROP FUNCTION IF EXISTS ticketItemPrice;
DROP TRIGGER IF EXISTS beforeAddMenuCategory;
DROP TRIGGER IF EXISTS beforeAddMenuItem;
DROP TRIGGER IF EXISTS beforeAddMenuModificationCategory;
DROP TRIGGER IF EXISTS beforeAddMenuModificationItem;
DROP TRIGGER IF EXISTS beforeUpdateMenuCategory;
DROP TRIGGER IF EXISTS beforeUpdateMenuItem;
DROP TRIGGER IF EXISTS beforeUpdateMenuModificationCategory;
DROP TRIGGER IF EXISTS beforeUpdateMenuModificationItem;
DROP TRIGGER IF EXISTS afterDeleteMenuCategory;
DROP TRIGGER IF EXISTS afterDeleteMenuItem;
DROP TRIGGER IF EXISTS afterDeleteMenuModificationCategory;
DROP TRIGGER IF EXISTS afterDeleteMenuModificationItem;
DROP PROCEDURE IF EXISTS createUser;
DROP FUNCTION IF EXISTS sessionUsername;
DROP FUNCTION IF EXISTS sessionRole;
DROP FUNCTION IF EXISTS getMods;
DROP FUNCTION IF EXISTS loggedIn;
DROP FUNCTION IF EXISTS menuItemModifications;

DELIMITER $$
CREATE TRIGGER beforeAddMenuCategory
BEFORE INSERT ON MenuCategories FOR EACH ROW
BEGIN
	INSERT INTO QuickCodes (id) VALUES (NEW.quickCode);
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER beforeAddMenuItem
BEFORE INSERT ON MenuItems FOR EACH ROW
BEGIN
	INSERT INTO QuickCodes (id) VALUES (NEW.quickCode);
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER beforeAddMenuModificationCategory
BEFORE INSERT ON MenuModificationCategories FOR EACH ROW
BEGIN
	INSERT INTO QuickCodes (id) VALUES (NEW.quickCode);
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER beforeAddMenuModificationItem
BEFORE INSERT ON MenuModificationItems FOR EACH ROW
BEGIN
	INSERT INTO QuickCodes (id) VALUES (NEW.quickCode);
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER afterDeleteMenuCategory
AFTER DELETE ON MenuCategories FOR EACH ROW
BEGIN
	DELETE FROM QuickCodes WHERE id = OLD.quickCode;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER afterDeleteMenuItem
AFTER DELETE ON MenuItems FOR EACH ROW
BEGIN
	DELETE FROM QuickCodes WHERE id = OLD.quickCode;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER afterDeleteMenuModificationCategory
AFTER DELETE ON MenuModificationCategories FOR EACH ROW
BEGIN
	DELETE FROM QuickCodes WHERE id = OLD.quickCode;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER afterDeleteMenuModificationItem
AFTER DELETE ON MenuModificationItems FOR EACH ROW
BEGIN
	DELETE FROM QuickCodes WHERE id = OLD.quickCode;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER beforeUpdateMenuCategory
BEFORE UPDATE ON MenuCategories FOR EACH ROW
BEGIN
	IF (OLD.quickCode <> NEW.quickCode) THEN
		IF ((SELECT COUNT(*) FROM menuCategories WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuItems WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuModificationCategories WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuModificationItems WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		END IF; 
	END IF;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER beforeUpdateMenuItem
BEFORE UPDATE ON MenuItems FOR EACH ROW
BEGIN
	IF (OLD.quickCode <> NEW.quickCode) THEN
		IF ((SELECT COUNT(*) FROM menuCategories WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuItems WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuModificationCategories WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuModificationItems WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		END IF; 
	END IF;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER beforeUpdateMenuModificationCategory
BEFORE UPDATE ON MenuModificationCategories FOR EACH ROW
BEGIN
	IF (OLD.quickCode <> NEW.quickCode) THEN
		IF ((SELECT COUNT(*) FROM menuCategories WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuItems WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuModificationCategories WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuModificationItems WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		END IF; 
	END IF;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER beforeUpdateMenuModificationItem
BEFORE UPDATE ON MenuModificationItems FOR EACH ROW
BEGIN
	IF (OLD.quickCode <> NEW.quickCode) THEN
		IF ((SELECT COUNT(*) FROM menuCategories WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuItems WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuModificationCategories WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		ELSEIF ((SELECT COUNT(*) FROM menuModificationItems WHERE quickCode = NEW.quickCode) = 1 ) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Quick Codes can only be associated with 1 item.';
		END IF; 
	END IF;
END$$
DELIMITER ;




DELIMITER $$
CREATE TRIGGER afterDeleteTicketModificationSplit
AFTER DELETE ON TicketAndSplit FOR EACH ROW
BEGIN
	DELETE FROM TicketItems WHERE OLD.ticketID = ticketID and OLD.splitID = splitID;
	DELETE FROM TableAssignments WHERE tableID = OLD.tableID;
END$$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER beforeInsertTableLog
BEFORE INSERT ON TableLog FOR EACH ROW
BEGIN
	
	IF ((SELECT COUNT(*) FROM EmployeeLog WHERE employeeID = NEW.authorizationID AND startTime IS NOT NULL AND endTime IS NULL) = 0) THEN
		-- authorizer isn't logged in
	    -- This is going to bog down the system the longer the EmployeeLog gets. Need to set up trigger to add/remove logged in employees from another table.
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Authorized host must be logged in!';
		
		
		-- authorizer has invalid roles for session to perform action
	ELSEIF ((NEW.ticketID IS NOT NULL) AND (SELECT COUNT(*) FROM TicketAndSplit WHERE ticketID = NEW.ticketID) = 0) THEN
		-- if a ticket number is specified, but it's invalid
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Specifed ticket number does not exist!';
	
		-- If you are assigning a server to table, but they aren't logged in or don't have server roles for session
	ELSEIF (NEW.tableID IS NOT NULL AND (SELECT COUNT(*) FROM Tables WHERE id = NEW.tableID AND status IN ('Occupied', 'Unavailable')) = 1) THEN
		-- if you're assigning a ticket to a table, but it's occupied or unavailable	
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Cannot assign a Ticket to an Unassigned or Occupied Table!';
	ELSEIF (NEW.action = 'Bused' AND (SELECT COUNT(*) FROM Tables WHERE id = NEW.tableID AND status = 'Bussing') = 0) THEN	
		-- if you're setting the bused flag but the table isn't flagged as bussing
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Specified Table is not marked for bussing. Cannot set status to bused.';
	-- ELSEIF () THEN
		-- if you're removing the only server, but the table is occupied and you're not removing the ticket
	
		-- if you're trying to set the table as disabled but the table is occupied
	END IF;
	
	
END$$
DELIMITER ;

-- add employee to table
DELIMITER $$
CREATE PROCEDURE assignEmployeeToTable(IN employeeID INT UNSIGNED, IN tableID VARCHAR(3), authorizationID INT UNSIGNED)
BEGIN
	DECLARE empID INT UNSIGNED;
	DECLARE hashReturn CHAR(60);
	
END$$
DELIMITER ;

-- add remove employee from table
DELIMITER $$
CREATE PROCEDURE removeEmployeeFromTable(IN employeeID INT UNSIGNED, IN tableID VARCHAR(3), authorizationID INT UNSIGNED)
BEGIN
		
END$$
DELIMITER ;

-- add ticket to table
DELIMITER $$
CREATE PROCEDURE assignTicketToTable(IN ticketID VARCHAR(3), IN tableID VARCHAR(3), authorizationID INT UNSIGNED)
BEGIN
		
END$$
DELIMITER ;

-- remove ticket from table
DELIMITER $$
CREATE PROCEDURE removeTicketFromTable(IN ticketID VARCHAR(3), IN tableID VARCHAR(3), authorizationID INT UNSIGNED)
BEGIN
		
END$$
DELIMITER ;

-- disable table
DELIMITER $$
CREATE PROCEDURE disableTable(IN tableID VARCHAR(3))
BEGIN
		
END$$
DELIMITER ;

-- enable table
DELIMITER $$
CREATE PROCEDURE enableTable(IN tableID VARCHAR(3))
BEGIN
		
END$$
DELIMITER ;

-- set table status to bussed
DELIMITER $$
CREATE PROCEDURE bussingComplete(IN tableID VARCHAR(3))
BEGIN
		
END$$
DELIMITER ;


DELIMITER $$
CREATE TRIGGER afterInsertTableLog
AFTER INSERT ON TableLog FOR EACH ROW
BEGIN
	IF (NEW.action = 'Add' AND NEW.ticketID IS NOT NULL AND NEW.employeeID IS NOT NULL) THEN
		UPDATE TicketAndSplit SET tableID = NEW.tableID WHERE ticketID = NEW.ticketID;
		INSERT INTO TableAssignments VALUES(NEW.employeeID, NEW.tableID);
		UPDATE Tables SET status = 'Seated' WHERE id = NEW.tableID;
	ELSEIF (NEW.action = 'Add' AND NEW.ticketID IS NOT NULL) THEN
		UPDATE TicketAndSplit SET tableID = NEW.tableID WHERE ticketID = NEW.ticketID;
		UPDATE Tables SET status = 'Seated' WHERE id = NEW.tableID;
	ELSEIF (NEW.action = 'Add' AND NEW.employeeID IS NOT NULL) THEN
		INSERT INTO TableAssignments VALUES(NEW.employeeID, NEW.tableID);
		IF (SELECT COUNT(*) FROM TicketAndSplit WHERE tableID = NEW.TableID > 0) THEN
			UPDATE Tables SET status = 'Seated' WHERE id = NEW.tableID;
		ELSE
			UPDATE Tables SET status = 'Open' WHERE id = NEW.tableID;
		END IF;
	ELSEIF (NEW.action = 'Remove' AND NEW.ticketID IS NOT NULL AND NEW.employeeID IS NOT NULL) THEN
		DELETE FROM TableAssignments WHERE employeeID = NEW.employeeID AND tableID = NEW.tableID;
		UPDATE TicketAndSplit SET tableID = NULL WHERE ticketID = NEW.ticketID;
		UPDATE Tables SET status = 'Bussing' WHERE id = NEW.tableID;
	ELSEIF (NEW.action = 'Remove' AND NEW.ticketID IS NOT NULL) THEN
		UPDATE TicketAndSplit SET tableID = NULL WHERE ticketID = NEW.ticketID;
		UPDATE Tables SET status = 'Bussing' WHERE id = NEW.tableID;
	ELSEIF (NEW.action = 'Remove' AND NEW.employeeID IS NOT NULL) THEN
		DELETE FROM TableAssignments WHERE employeeID = NEW.employeeID and tableID = NEW.tableID;
		IF (((SELECT COUNT(*) FROM TicketAndSplit WHERE tableID = NEW.TableID) = 0) AND 
		((SELECT COUNT(*) FROM Tables WHERE id = NEW.tableID and status = 'Bussing')) = 0) THEN
			UPDATE Tables SET status = 'Unassigned' WHERE id = NEW.tableID;
		END IF;
	ELSEIF (NEW.action = 'Bused') THEN
		IF ((SELECT COUNT(*) FROM TableAssignments WHERE tableID = NEW.TableID) = 0) THEN
			UPDATE Tables SET status = 'Unassigned' WHERE id = NEW.tableID;
		ELSE
			UPDATE Tables SET status = 'Open' WHERE id = NEW.tableID;
		END IF;
	ELSEIF (NEW.action = 'Disable') THEN
		UPDATE Tables SET status = 'Unavailable' WHERE id = NEW.tableID;
	ELSEIF (NEW.action = 'Enable') THEN
		IF ((SELECT COUNT(*) FROM TableAssignments WHERE tableID = NEW.TableID) = 0) THEN
			UPDATE Tables SET status = 'Unassigned' WHERE id = NEW.tableID;
		ELSE
			UPDATE Tables SET status = 'Open' WHERE id = NEW.tableID;
		END IF;
	END IF;
END$$
DELIMITER ;

DELIMITER $$
CREATE FUNCTION userPasswordHash(uname VARCHAR(25)) RETURNS CHAR(60)
BEGIN
	DECLARE empID INT UNSIGNED;
	DECLARE hashReturn CHAR(60);
	IF ((SELECT COUNT(*) FROM Employees WHERE userName = uname) = 0) THEN
		-- Invalid Employee ID
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Username not found!';
	ELSE
		SELECT passwordBCrypt INTO hashReturn FROM Employees WHERE userName = uname;
		RETURN hashReturn;
	END IF;
	
END$$
DELIMITER ;

DELIMITER $$

CREATE FUNCTION usernameFromID(empID INT UNSIGNED) RETURNS VARCHAR(25)
BEGIN
	DECLARE uname VARCHAR(25);
	IF ((SELECT COUNT(*) FROM Employees WHERE id = empID) = 0) THEN
		-- Invalid Employee ID
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Invalid Employee ID!';
	ELSE
		SELECT userName INTO uname FROM Employees WHERE id = empID;
		RETURN uname;
	END IF;
	
END$$
DELIMITER ;

DELIMITER $$
CREATE FUNCTION idFromUsername(uname VARCHAR(25)) RETURNS INT UNSIGNED
BEGIN
	DECLARE empID INT UNSIGNED;
	IF ((SELECT COUNT(*) FROM Employees WHERE userName = uname) = 0) THEN
		-- Invalid Username
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Username not found!';
	ELSE
		SELECT id INTO empID FROM Employees WHERE userName = uname;
		RETURN empID;
	END IF;
END$$
DELIMITER ;

-- parent Quick code is required because Menu Items can belong to more than 1 Menu Item Category.
-- specifying the parent uniquely identifies a specific instance of the menu item.
DELIMITER $$
CREATE FUNCTION menuItemPrice(qc VARCHAR(10), parentQuickCode VARCHAR(10)) RETURNS DECIMAL(6, 2)
BEGIN
	DECLARE prc DECIMAL(6, 2);
	SELECT price INTO prc FROM MenuItems WHERE id = qc; 
	RETURN mipHelperFunction(parentQuickCode, prc, NULL, NULL, NULL);
END$$
DELIMITER ;

DELIMITER $$
CREATE FUNCTION mipHelperFunction(qc VARCHAR(10), basePrice DECIMAL(6, 2), minPercentage DECIMAL(6, 2), minDiscount DECIMAL(6, 2), minPriceOverride DECIMAL(6,2)) RETURNS DECIMAL(6, 2)
BEGIN
	DECLARE selectedValue DECIMAL(6, 2);
	DECLARE defPrice DECIMAL(6, 2);
	DECLARE done INT DEFAULT FALSE;
	DECLARE parentQC VARCHAR(10);
	DECLARE myCursor CURSOR
		FOR 
			SELECT priceModificationValue FROM MenuModificationItems INNER JOIN MenuAssociations ON MenuModificationItems.quickCode = MenuAssociations.childQuickCode WHERE parentQuickCode = qc;
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
	
	OPEN myCursor;
	modItemsLoop:
	LOOP
		FETCH myCursor INTO selectedValue;
		IF (done = 1) THEN
			LEAVE modItemsLoop;
		END IF;
		IF (selectedValue = 0) THEN
			CLOSE myCursor;
			RETURN 0;
		ELSEIF (selectedValue < 0 AND (selectedValue < minDiscount OR minDiscount IS NULL)) THEN
			SET minDiscount = selectedValue;
		ELSEIF (selectedValue > 0 AND selectedValue < 1 and (selectedValue < minDiscount OR minDiscount IS NULL)) THEN
			SET minPercentage = selectedValue;
		ELSEIF (selectedValue >= 1 AND (selectedValue < minPriceOverride OR minPriceOverride IS NULL)) THEN
			SET minPriceOverride = selectedValue;
		END IF;
	END LOOP modItemsLoop;
	CLOSE myCursor;

	IF (basePrice IS NULL) Then
		SELECT defaultPrice INTO basePrice FROM MenuCategories WHERE quickCode = qc;
	End If;

	SELECT parentQuickCode INTO parentQC FROM TableAssociations WHERE childQuickCode = qc;
	IF (basePrice - minDiscount < 0) THEN
		SET minDiscount = 0;
	END IF;
	IF parentQC IS NULL THEN
		IF (basePrice IS NULL and minPriceOverride IS NULL) Then
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Menu Item doesn''t have a price set, and cannot be inferred from ancestors!';
		ELSE
			SET selectedValue = basePrice;
			IF (minPercentage IS NOT NULL AND basePrice * minPercentage < selectedValue) THEN
				SET selectedValue = basePrice * minPercentage;
			End IF;
			IF (minDiscount IS NOT NULL AND basePrice + minDiscount < selectedValue) THEN
				SET selectedValue = basePrice + minDiscount;
			End IF;
			IF (minPriceOverride IS NOT NULL AND minPriceOverride < selectedValue) THEN
				SET selectedValue = basePrice + minDiscount;
			End IF;
			RETURN selectedValue;
		END IF;
	ELSE
		RETURN mipHelperFunction(parentQC, basePrice, minPercentage, minDiscount, minPriceOverride);
	END IF;
	
END$$
DELIMITER ;

DELIMITER $$
CREATE FUNCTION menuItemModifications(qc VARCHAR(10), parentQC VARCHAR(10)) RETURNS VARCHAR(500)
BEGIN
	DECLARE inString VARCHAR(10);
	DECLARE myString VARCHAR(500);

	DECLARE done INT DEFAULT FALSE;
	DECLARE myCursor CURSOR
		FOR 
			SELECT childQuickCode FROM MenuAssociations INNER JOIN MenuModificationCategories ON MenuAssociations.childQuickCode = MenuModificationsCategories.quickCode WHERE parentQuickCode = parentQC;
	DECLARE myCursor2 CURSOR
		FOR 
			SELECT childQuickCode FROM MenuAssociations INNER JOIN MenuModificationCategories ON MenuAssociations.childQuickCode = MenuModificationsCategories.quickCode WHERE parentQuickCode = qc;
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
	
	OPEN myCursor;
	modItemsLoop:
	LOOP
		FETCH myCursor INTO inString;
		IF (done = 1) THEN
			LEAVE modItemsLoop;
		END IF;
		UPDATE myString SET myString = myString + ',' + inString;
		
	END LOOP modItemsLoop;
	CLOSE myCursor;
	SET done = FALSE;
	
	OPEN myCursor2;
	modItemsLoop2:
	LOOP
		FETCH myCursor INTO inString;
		IF (done = 1) THEN
			LEAVE modItemsLoop2;
		END IF;
		UPDATE myString SET myString = myString + ',' + inString;
		
	END LOOP modItemsLoop2;
	CLOSE myCursor2;

	RETURN myString + ',';

END$$
DELIMITER ;



-- function needs to be recoded to include appropriate price calculation
DELIMITER $$
CREATE FUNCTION ticketItemPrice(ticketItemID INT UNSIGNED) RETURNS DECIMAL(6, 2)
BEGIN
	DECLARE miQuickCode VARCHAR(10);
	DECLARE price DECIMAL(6, 2);
	SELECT menuItemQuickCode INTO miQuickCode FROM TicketItems WHERE id = ticketItemID;
	SELECT basePrice INTO price FROM MenuItems WHERE quickCode = miQuickCode;
	RETURN price;	
END$$
DELIMITER ;

DELIMITER $$
CREATE FUNCTION sessionRole(token VARCHAR(60)) RETURNS INT UNSIGNED
BEGIN
	DECLARE empID INT UNSIGNED;
	DECLARE role INT UNSIGNED;
	SELECT id INTO empID FROM Employees WHERE accessToken = token AND accessTokenExpiration > NOW();
	IF (empId IS NULL) THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Access Token Expired Or Doesn''t Exist!';
	ELSE
		SELECT employeeRole INTO role FROM ActiveEmployees WHERE employeeID = empID;
		RETURN role;
	END IF;
END$$
DELIMITER ;


DELIMITER $$
CREATE FUNCTION sessionUsername(token VARCHAR(60)) RETURNS VARCHAR(25)
BEGIN
	 DECLARE uname VARCHAR(25);
	 SELECT userName INTO uname FROM Employees WHERE accessToken = token AND accessTokenExpiration > NOW();
	IF (uname IS NULL) THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Access Token Expired Or Doesn''t Exist!';
	ELSE
		RETURN uname;
	END IF;
END$$
DELIMITER ;


DELIMITER $$
CREATE FUNCTION loggedIn(uname VARCHAR(25)) RETURNS BOOLEAN
BEGIN
	DECLARE endTime DATETIME;
	DECLARE empID INT UNSIGNED;
	SELECT id INTO empID FROM Employees WHERE userName = uname;
	SELECT accessTokenExpiration INTO endTime FROM Employees WHERE userName = uname;
	IF (empID IS NULL) THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Username Not Found!';
	ELSEIF (endTime IS NULL OR endTime < NOW()) THEN
		RETURN FALSE;
	ELSE
		RETURN TRUE;
	END IF;
END$$
DELIMITER ;


DELIMITER $$
CREATE PROCEDURE createUser(IN lName VARCHAR(50), fName VARCHAR(60), IN uName VARCHAR(25), IN pHash VARCHAR(60), IN roles TINYINT UNSIGNED)
BEGIN
	INSERT INTO Employees (lastName, firstName, userName, passwordBCrypt, roleLevel) VALUES (lName, fName, uname, pHash, roles);
END$$
DELIMITER ;


DELIMITER $$
CREATE PROCEDURE login(IN requestedUsername VARCHAR(25), IN requestedRoles TINYINT UNSIGNED, IN newAccessToken varchar(60))
BEGIN
	DECLARE allowedRoles TINYINT UNSIGNED;
	DECLARE empID INT UNSIGNED;
	DECLARE timeoutMins INT UNSIGNED;
	IF ((SELECT COUNT(*) FROM Employees WHERE userName = requestedUsername) = 0) THEN
		-- Invalid Employee ID
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Username not found!';
	ELSE
		SELECT roleLevel INTO allowedRoles FROM Employees WHERE userName = requestedUsername;
		
		IF (allowedRoles & requestedRoles <> requestedRoles) THEN
			-- Invalid Requested Roles
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'You do not have the authorization to login with the role you sepcified!';
		ELSEIF ((SELECT COUNT(*) FROM Employees WHERE userName = requestedUsername AND accessToken IS NOT NULL AND accessTokenExpiration > now()) = 1) THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'You are already logged in elsewhere!';
		ELSEIF ((SELECT COUNT(*) FROM Employees WHERE accessToken = newAccessToken AND userName <> requestedUsername) = 1 ) THEN
			-- Another user is already logged in using your access key.
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Access Token Not Unique! Retry Login.';
		ELSE
					
			SELECT id INTO empID FROM Employees WHERE userName = requestedUsername;
			UPDATE EmployeeLog SET endTime = NOW() WHERE employeeID = empID and endTime IS NULL;
			INSERT INTO EmployeeLog (employeeID, employeeRole) VALUES(empID, requestedRoles);
			DELETE FROM ActiveEmployees WHERE employeeID = empID;
			INSERT INTO ActiveEmployees (employeeID, employeeRole) VALUES (empID, requestedRoles);
			SELECT (sessionTimeoutInMins * 100) INTO timeoutMins FROM Config;	
			UPDATE employees SET accessToken = newAccessToken, accessTokenExpiration = ADDTIME(NOW(), timeoutMins) WHERE userName = requestedUsername;
		END IF;
	END IF;
	
END$$
DELIMITER ;

DELIMITER $$
CREATE PROCEDURE logout(IN uname VARCHAR(25))
BEGIN
	DECLARE empID INT UNSIGNED;
	IF ((SELECT COUNT(*) FROM Employees WHERE userName = uname) = 0) THEN
		-- Invalid Employee ID
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Username not found!';
	ELSE
		SELECT id INTO empID FROM Employees WHERE userName = uname;
		UPDATE EmployeeLog SET endTime = NOW() WHERE employeeID = empID and endTime IS NULL;
		UPDATE Employees SET accessToken = NULL, accessTokenExpiration = NULL WHERE userName = uname;
		DELETE FROM ActiveEmployees WHERE employeeID = empID;
	END IF;
	
END$$
DELIMITER ;
